#!/bin/bash
# wrapper script for adaptive optics algorithm
#
# default parameters
seed=""
start="1"
init=3
restore=0
restart=0
helpmode=0
theta="0.5"
expectinit=0
expectrestart=0
expectmaxiterations=0
expecttheta=0
maxiterations=5
complex=0
sp=0
spoption=""
coption=""
so=0
parallel=0
peierls=0
nosym=0
inter=0
band=0
bandoption=""


for i in $*; do
   case "$i" in
      "-init")
      expectinit=1
      ;;
      "-restore")
      restore=1;
      ;;
      "-restart")
      expectrestart=1;
      ;;
      "-h")
      helpmode=1;
      ;;
      "-help")
      helpmode=1;
      ;;
      "-i")
      expectmaxiterations=1;
      ;;
      "-th")
      expecttheta=1;
      ;;
      "-p")
      parallel=1;
      ;;
      "-peierls")
      peierls=1;
      ;;
      "-c")
      complex=1;
      coption="-c"
      ;;
      "-nosym")
      nosym=1;
      ;;
      "-up")
      sp=1;
      spoption="-up"
      ;;
      "-dn")
      sp=1;
      spoption="-dn"
      ;;
      "-so")
      so=1;
      ;;
       "-inter")
      inter=1;
      ;;
       "-band")
      band=1;
      bandoption="-band"
      ;;
      *)
      optiontest=$(echo "$i" | cut -c1)
      if [ "$optiontest" == '-' ]; then
         echo "error in your arguments:  $i   is not a valid option";
         exit 0
      fi
#       echo $i"restarter"$expectrestart
      if [ $expectrestart -eq 1 ]; then
         restart=$i
         expectrestart=0
      elif [ $expectmaxiterations -eq 1 ]; then
         maxiterations=$i
         expectmaxiterations=0
      elif [ $expecttheta -eq 1 ]; then
         theta=$i
         expecttheta=0
      elif [ $expectinit -eq 1 ]; then
         init=$i
         expectinit=0
      else
         seed=$i
      fi
      ;;
   esac
done

# echo "seed="$seed
if [ "$seed" == "" ]; then
#    echo activate
   helpmode=1
fi

if [ $helpmode -eq 1 ]; then
  #echo "the answer to life the universe and everything is 64 [wien2k version]"
  echo "woptic: adaptive algorithm to compute optical conductivity, dc conductivity"
  echo "        and thermopower"
  echo "usage: woptic [options] case"
  echo "options: -i value: number of total iterations"
  echo "         -th value : change refinement 'harshness'(0-1)"
  echo "         -p : use parallel lapw1(.machine file present)"
  echo "         -c : use complex lapw1,optic"
  echo "         -so :use lapwso to compute energies"
  echo "         -up/dn :use lapw1 -up/-dn to compute energies"
  echo "         -inter :focus in refinement on higher energies(usually inter-orbital)"
  echo "         -nosym : do not use symmetry operations(slow)"
  echo "         -restart value: restart from iteration value"
  echo "         -peierls : optimize runtime for Peierls approximation"
  echo "example: woptic -i 3 SrVO3"
  exit 0
fi

#test file existence
if [ ! -f $seed.symop ]; then
  echo "Error: woptic requires "$seed".symop. Please run x optic at least once"
  exit 0
fi
if [ $sp -eq 1 ]; then
   REQFILES="woptin struct scf2up outputkgen_orig inop"
else
   REQFILES="woptin struct scf2 outputkgen_orig inop"
fi
for FORMAT in $REQFILES; do
     REQFILE="${seed}.${FORMAT}"
     if [ ! -r $REQFILE ]; then
	 echo "Error: woptic requires $REQFILE"
         exit 0
     fi
done



mode=$(head $seed.woptin -n 1 | awk '{print $2}')
neminw2k=$(head $seed.woptin -n 3 | tail -n 1 | awk '{print $1}')
nemaxw2k=$(head $seed.woptin -n 3 | tail -n 1 | awk '{print $2}')
nemin=$(head $seed.woptin -n 3 | tail -n 1 | awk '{print $3}')
nemax=$(head $seed.woptin -n 3 | tail -n 1 | awk '{print $4}')
nbw2k=$(expr $nemaxw2k - $neminw2k + 1 )
nb=$(expr $nemax - $nemin + 1 )
# echo $mode $nemin $nemax $neminw2k $nemaxw2k
# echo $nbw2k
runlapw1=0
if [ $mode -ne 1 ]; then
  runlapw1=1
elif [ $mode -eq 1 -a \( $nemin -ne $neminw2k \) ]; then
  runlapw1=1
elif [ $mode -eq 1 -a \( $nemax -ne $nemaxw2k \) ]; then
  runlapw1=1
fi

# echo $runlapw1



# echo "restore ",$restore
# echo "restart ",$restart
# echo "help ",$helpmode
# echo "theta ",$theta
# echo "seed ",$seed

cp $W2WROOT/woptic/symop .

# test which files are avaliable
if [ -f .machines ]; then
   nmachines=$(wc -l .machines | awk '{print $1}')
   parallel=1
else
   parallell=0
fi


# if [ ! -f $seed.joint ]; then
#  echo "Error: woptic requires "$seed".joint. Please run x joint at least once"
#  exit 0
# fi
# if [ ! -f $seed.sigmak ]; then
#  echo "Error: woptic requires "$seed".sigmak. Please run x kram at least once"
#  exit 0
# fi

# restore mode
if [ $restore -eq 1 ]; then
   echo "woptic: restore initial state klist,kgen files"
   cp $seed.kgen0 $seed.kgen
   cp $seed.kgen_full0 $seed.kgen_full
   cp $seed.klist0 $seed.klist
   cp $seed.klist_full0 $seed.klist_full
   #cp $seed.symop0 $seed.symop
   exit 0
fi 

#header
echo " +++ WOPTIC: ADAPTIVE ALGORITHM FOR OPT. COND. +++"
if [ $mode -eq 1 ]; then
   echo " MODE: PEIERLS"
elif [ $mode -eq 2 ]; then
   echo " MODE: DIPOLE MATRIX ELEMENTS, IN WANNIER BASIS"
elif [ $mode -eq 3 ]; then
   echo " MODE: DIPOLE MATRIX ELEMENTS, IN K-DIAGONAL BASIS"
elif [ $mode -eq 4 ]; then
   echo " MODE: DIPOLE MATRIX ELEMENTS, IN K-DIAGONAL BASIS, wien2k only"
else
   echo " Unknown mode"
   exit -1
fi
echo " options:"
echo "    runlapw1  = $runlapw1"
echo "    parallel  = $parallel"
echo "    init      = $init"
echo "    theta     = $theta"
echo "    maxiter   = $maxiterations"
echo "    complex   = $complex"
echo "    sp        = $sp"
echo "    so        = $so"
echo "    nosym     = $nosym"
echo "    inter     = $inter"
echo "    band     =  $band"



  

if [ $restart -eq 0 ]; then
   if [ $nosym -eq 1 ]; then
       cp $seed.struct $seed.struct_tmp
       cp $seed.ksym $seed.struct
   fi
   refine_tetra -input=init$init $seed
   if [ $nosym -eq 1 ]; then
       cp $seed.struct_tmp $seed.struct
   fi
#    refine_tmesh_clean_fast -th=1.0 -input=wien2k $seed
   cp $seed.kgen_refined $seed.kgen
   cp $seed.kgen_full_refined $seed.kgen_full
   cp $seed.klist_refined $seed.klist
   cp $seed.klist_full_refined $seed.klist_full
   cp $seed.voe_refined $seed.voe
   cp $seed.map_refined $seed.map
   #initialize history
   echo "# 0 0 0" > $seed.kcontribw
   echo "0 0 0" > $seed.ham_old
   echo "0" > $seed.mommat_old
   if [ $sp -eq 1 ]; then
      grep ":FER" $seed.scf2up >$seed.fermienergy
   else
      grep ":FER" $seed.scf2 >$seed.fermienergy
   fi
#    rm $seed.old_energy
 else
   start=$restart
   restart=$(expr $restart - 1 )
	echo "  restart from iteration "$start
#    echo $maxiterations
#    exit 0
	cp $seed.kgen$start $seed.kgen
	cp $seed.kgen_full$start $seed.kgen_full
	cp $seed.klist$start $seed.klist
	cp $seed.klist_full$start $seed.klist_full
	cp $seed.voe$start $seed.voe
	cp $seed.map$start $seed.map
#reload history
	echo $restart
   cp $seed.kcontribw$restart $seed.kcontribw
   head -n 3 $seed.kcontribw
   cp $seed.klist_refined$restart $seed.klist_refined
   cp $seed.ham_fine$restart $seed.ham_old
   cp $seed.mommat$restart $seed.mommat_old
   cp $seed.$restart"energy" $seed.energy
   cp $seed.$restart"energy" $seed.old_energy
   cp $seed.wdosw$restart $seed.wdosw
   cp $seed.wdoskcontribw$restart $seed.wdoskcontribw
   cp $seed.K1w$restart $seed.K1w
fi

for ((  i = $start ;  i <= $maxiterations;  i++  )) do
  echo "+++ iteration "$i" +++"
  #store local mesh history
  cp $seed.klist $seed.klist$i
  cp $seed.klist_full $seed.klist_full$i
  cp $seed.kgen_full $seed.kgen_full$i
  cp $seed.kgen $seed.kgen$i
  cp $seed.map $seed.map$i

  #determine how many parallel files there are
  #and join them with the previous run
   if [ $band -eq 1 ]; then
       cp $seed.klist_band $seed.klist
   fi
  nk=$(expr $(wc $seed.klist -l | awk '{print $1}') - 2)   #number of kpoints
  echo "  new k-points: "$nk
  if [ $nk -ne 0 ]; then  #special case where not much is to do here
        if [ $parallel -eq 1 ]; then
                if [ $runlapw1 -eq 1 ]; then
                    if [ $so -eq 1 ]; then
                       if [ $sp -eq 1 ]; then
                          x lapw1 -up -p $coption
                          x lapw1 -dn -p $coption
                          x lapwso -up -p $coption
                       else
                          x lapw1 -p $coption  #this is not yet working
                       fi
                    else
	    		x lapw1 -p $coption #work with klist
                    fi
                fi
# 		modi=$(expr $nk / $nmachines)
# 		if [ $modi -eq 0 ]; then
# 			nfiles=$nmachines
# 			leftover=1
# 		else
# 			nfiles=$(expr $nk / $modi)
                    
# 			leftover=$(expr $nk % $modi)
# 		fi
# 		if [ $leftover -eq 0 ]; then
		#                echo "  combine "$nfiles
                nfiles=$(ls $seed.klist_[1-9]* | wc -l)
                    if [ $so -eq 1 ]; then
		       join_vectorfiles -soup $coption $seed $nfiles
                       join_vectorfiles -sodn $coption $seed $nfiles
                       cp $seed.energysoup $seed.energy
                    else
                       join_vectorfiles $coption $seed $nfiles
                    fi
# 		else
# 			tmp=$(expr $nfiles + 1)
		#                echo "nfiles "$tmp
#                     if [ $so -eq 1 ]; then
# 		        join_vectorfiles -soup $coption $seed $tmp
#                         join_vectorfiles -sodn $coption $seed $tmp
#                     else
#                         join_vectorfiles $coption $seed $tmp
#                     fi
# 		fi
	else
            if [ $runlapw1 -eq 1 ]; then
               if [ $so -eq 1 ]; then
                   if [ $sp -eq 1 ]; then
	     	      x lapw1 -up $coption
		      x lapw1 -dn $coption  
		      x lapwso -up $coption 
		      cp $seed.energysoup $seed.energy
		   else
		      x lapw1 $coption #this is not yet working
		   fi
              else
	           x lapw1 $coption
	      fi
	    fi
	fi
	if [ $mode -ne 1 ]; then
              if [ $so -eq 1 ]; then
	          if [ $sp -eq 1 ]; then
		      x opticc -so -up
		      cp $seed.mommatup $seed.mommat
		  else
		      x optic -so $coption #this is not yet working
		  fi
	      else
		  x optic $coption #work with klist
              fi
        fi
	if [ $mode -eq 1 ]; then
	      cp $seed.klist ktmp.klist
	      cp $seed.klist_full $seed.klist
	fi

#write_win -renew $seed >tmp
#wannier90.x $seed 
	convert_Hamiltonian $seed

	if [ $mode -ne 1 ]; then
		      combine_hamfiles $seed
		      cp $seed.ham_joined $seed.ham_fine
		      cp $seed.ham_joined $seed.ham_old
		      cp $seed.mommat_joined $seed.mommat
		      cp $seed.mommat_joined $seed.mommat_old
	fi
	if [ $i -ne 1 ]; then
	     if [ $runlapw1 -eq 1 ]; then
		      tmplines=$(wc -l $seed.energy | awk '{print $1}')
	         natoms=$(grep "elements:" $seed.woptoutw | awk '{print $4}')
                 nelines=$( expr $tmplines - 2 \* $natoms ) 
	         cp $seed.energy tmp.energy 
              	cp $seed.old_energy $seed.energy 
	        tail -n $nelines tmp.energy >>$seed.energy
	      fi
	fi
    elif [ $mode -eq 1 ]; then
         #for Peierls we have to Fourier transform full Hamiltonian even 
         #if there is no new symmetrized k-point
         cp $seed.klist ktmp.klist
         cp $seed.klist_full $seed.klist
         convert_Hamiltonian $seed
    fi
#   if [ $restart -ne $i ]; then
        if [ $band -ne 1 ]; then
	   cp $seed.klist_refined $seed.klist
        fi
#   elif [ $mode -eq 1 ]; then
#      cp ktmp.klist $seed.klist
#   fi

	if [ $nosym -eq 1 ]; then
	   cp $seed.ksym $seed.struct
	fi
#  	if [ $i -eq 1 ]; then
#  	exit 0
#  	fi
#main run to compute optical conductivity on given mesh
	woptic_main $seed $bandoption
        if [ $band -eq 1 ]; then
            exit 0
        fi
	if [ $nosym -eq 1 ]; then
	   cp $seed.struct_tmp $seed.struct
	fi
	grep "sumrules2" $seed.woptoutw
	grep "dc cond" $seed.woptoutw
	grep "thermopower" $seed.woptoutw

#store history
	cp $seed.kcontribw $seed.kcontribw$i
	cp $seed.wdosw $seed.wdosw$i
#   cp $seed.wdoskcontribw $seed.wdoskcontribw$i
	cp $seed.voe $seed.voe$i
# cp $seed.kcontrib $seed.kcontrib$i
	cp $seed.optcondw $seed.optcondw$i
	cp $seed.woptoutw $seed.woptoutw$i
#   cp $seed.ham_fine $seed.ham_fine$i
#    cp $seed.mommat $seed.mommat$i
	cp $seed.K1w $seed.K1w$i
#   cp $seed.energy $seed.energy$i
#  cp $seed.optdsum $seed.optdsum$i
	cp $seed.win $seed.win$i
	cp $seed.energy $seed.old_energy
	cp $seed.energy $seed.$i"energy"
#  

#refine k-mesh
#   refine_tmesh_clean_fast -th=$theta $seed >$seed.woptoutref$i
#         if [ $i -eq 9 ]; then
#             exit 0
#         fi
        if [ $inter -eq 1 ]; then
#             echo "call inter"
	    refine_tetra -th=$theta -inter $seed >$seed.woptoutref$i
        else
            refine_tetra -th=$theta $seed >$seed.woptoutref$i
        fi
	grep "estimator =" $seed.woptoutref$i
        cp $seed.klist_refined $seed.klist_refined$i

  if [ $i -eq $maxiterations ]; then
      exit 0
  fi

  #update k-mesh
  cp $seed.kgen_refined $seed.kgen
  cp $seed.kgen_full_refined $seed.kgen_full
  cp $seed.klist_new $seed.klist
  cp $seed.klist_full_refined $seed.klist_full
  cp $seed.voe_refined $seed.voe
  cp $seed.map_refined $seed.map
done

